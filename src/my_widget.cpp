#include "my_widget.hpp"
#include "ui_my_widget.h"  // auto-generated by uic
#include <simulation_interfaces/srv/get_spawnables.hpp>
#include <simulation_interfaces/srv/spawn_entity.hpp>
#include <simulation_interfaces/srv/get_entities.hpp>
#include <simulation_interfaces/srv/get_entity_state.hpp>
#include <simulation_interfaces/srv/set_entity_state.hpp>
#include <simulation_interfaces/srv/delete_entity.hpp>
#include <rclcpp/rclcpp.hpp>
#include <rclcpp_action/rclcpp_action.hpp>
#include <QMessageBox>

MyWidget::MyWidget(QWidget *parent)
        : QWidget(parent),
          ui_(new Ui::MyWidgetUI) {
    ui_->setupUi(this);
    node_ = rclcpp::Node::make_shared("qt_gui_node");

    connect(ui_->PushButtonRefresh, &QPushButton::clicked, this, &MyWidget::GetSpawnables);
    connect(ui_->SpawnButton, &QPushButton::clicked, this, &MyWidget::SpawnButton);
    connect(ui_->getAllEntitiesButton, &QPushButton::clicked, this, &MyWidget::GetAllEntities);
    connect(ui_->getEntityStateButton, &QPushButton::clicked, this, &MyWidget::GetEntityState);
    connect(ui_->setEntityStateButton, &QPushButton::clicked, this, &MyWidget::SetEntityState);
    connect(ui_->despawnButton, &QPushButton::clicked, this, &MyWidget::DespawnButton);

//    resize(300, 200);
}

MyWidget::~MyWidget() {
    delete ui_;
}

void MyWidget::DespawnButton() {
    auto client = node_->create_client<simulation_interfaces::srv::DeleteEntity>("/delete_entity");
    if (!client->wait_for_service(std::chrono::seconds(10))) {
        RCLCPP_ERROR(node_->get_logger(), "Service not available after waiting");
        return;
    }
    auto request = std::make_shared<simulation_interfaces::srv::DeleteEntity::Request>();
    request->entity = ui_->ComboEntities->currentText().toStdString();

    // Call the service
    auto future = client->async_send_request(request);
    if (rclcpp::spin_until_future_complete(node_, future) !=
        rclcpp::FutureReturnCode::SUCCESS) {
        RCLCPP_ERROR(node_->get_logger(), "Failed to call service");
        return;
    }
    auto response = future.get();
    if (response->result.result != simulation_interfaces::msg::Result::RESULT_OK) {
        RCLCPP_ERROR(node_->get_logger(), "Service call failed: %s", response->result.error_message.c_str());
        QMessageBox::warning(this, "Error", QString::fromStdString(response->result.error_message));
        return;
    }

}

void MyWidget::GetAllEntities() {
    // Create a client for the GetEntities service
    auto client = node_->create_client<simulation_interfaces::srv::GetEntities>("/get_entities");
    if (!client->wait_for_service(std::chrono::seconds(10))) {
        RCLCPP_ERROR(node_->get_logger(), "Service not available after waiting");
        return;
    }
    auto request = std::make_shared<simulation_interfaces::srv::GetEntities::Request>();

    // Call the service
    auto future = client->async_send_request(request);
    if (rclcpp::spin_until_future_complete(node_, future) !=
        rclcpp::FutureReturnCode::SUCCESS) {
        RCLCPP_ERROR(node_->get_logger(), "Failed to call service");
        return;
    }
    auto response = future.get();
    if (response->result.result != simulation_interfaces::msg::Result::RESULT_OK) {
        RCLCPP_ERROR(node_->get_logger(), "Service call failed: %s", response->result.error_message.c_str());
        QMessageBox::warning(this, "Error", QString::fromStdString(response->result.error_message));
        return;
    }
    // Process the response
    ui_->ComboEntities->clear();
    for (const auto &entity: response->entities) {
        ui_->ComboEntities->addItem(QString::fromStdString(entity));
    }
}

void MyWidget::GetEntityState() {
    // Create a client for the GetEntityState service
    auto client = node_->create_client<simulation_interfaces::srv::GetEntityState>("/get_entity_state");
    if (!client->wait_for_service(std::chrono::seconds(10))) {
        RCLCPP_ERROR(node_->get_logger(), "Service not available after waiting");
        return;
    }
    auto request = std::make_shared<simulation_interfaces::srv::GetEntityState::Request>();
    request->entity = ui_->ComboEntities->currentText().toStdString();

    // Call the service
    auto future = client->async_send_request(request);
    if (rclcpp::spin_until_future_complete(node_, future) !=
        rclcpp::FutureReturnCode::SUCCESS) {
        RCLCPP_ERROR(node_->get_logger(), "Failed to call service");
        return;
    }
    auto response = future.get();
    if (response->result.result != simulation_interfaces::msg::Result::RESULT_OK) {
        RCLCPP_ERROR(node_->get_logger(), "Service call failed: %s", response->result.error_message.c_str());
        QMessageBox::warning(this, "Error", QString::fromStdString(response->result.error_message));
        return;
    }

    // Process the response
    ui_->StatePosX->setValue(response->state.pose.position.x);
    ui_->StatePosY->setValue(response->state.pose.position.y);
    ui_->StatePosZ->setValue(response->state.pose.position.z);
}
void MyWidget::SetEntityState() {
    // Create a client for the SetEntityState service
    auto client = node_->create_client<simulation_interfaces::srv::SetEntityState>("/set_entity_state");
    if (!client->wait_for_service(std::chrono::seconds(10))) {
        RCLCPP_ERROR(node_->get_logger(), "Service not available after waiting");
        return;
    }
    auto request = std::make_shared<simulation_interfaces::srv::SetEntityState::Request>();
    request->entity = ui_->ComboEntities->currentText().toStdString();
    request->state.pose.position.x = ui_->StatePosX->value();
    request->state.pose.position.y = ui_->StatePosY->value();
    request->state.pose.position.z = ui_->StatePosZ->value();

    // Call the service
    auto future = client->async_send_request(request);
    if (rclcpp::spin_until_future_complete(node_, future) !=
        rclcpp::FutureReturnCode::SUCCESS) {
        RCLCPP_ERROR(node_->get_logger(), "Failed to call service");
        return;
    }
    auto response = future.get();
    if (response->result.result != simulation_interfaces::msg::Result::RESULT_OK) {
        RCLCPP_ERROR(node_->get_logger(), "Service call failed: %s", response->result.error_message.c_str());
        QMessageBox::warning(this, "Error", QString::fromStdString(response->result.error_message));
        return;
    }


}

void MyWidget::SpawnButton() {

    auto client = node_->create_client<simulation_interfaces::srv::SpawnEntity>("/spawn_entity");
    if (!client->wait_for_service(std::chrono::seconds(10))) {
        RCLCPP_ERROR(node_->get_logger(), "Service not available after waiting");
        return;
    }
    auto request = std::make_shared<simulation_interfaces::srv::SpawnEntity::Request>();
    request->name = ui_->lineEditName->text().toStdString();
    request->uri = ui_->ComboSpawables->currentText().toStdString();
    request->allow_renaming = true;
    request->initial_pose.pose.position.x = ui_->doubleSpinBoxX->value();
    request->initial_pose.pose.position.y = ui_->doubleSpinBoxY->value();
    request->initial_pose.pose.position.z = ui_->doubleSpinBoxZ->value();
    auto future = client->async_send_request(request);
    if (rclcpp::spin_until_future_complete(node_, future) !=
        rclcpp::FutureReturnCode::SUCCESS) {
        RCLCPP_ERROR(node_->get_logger(), "Failed to call service");
        return;
    }
    auto response = future.get();
    if (response->result.result != simulation_interfaces::msg::Result::RESULT_OK) {
        RCLCPP_ERROR(node_->get_logger(), "Service call failed: %s", response->result.error_message.c_str());
        QMessageBox::warning(this, "Error", QString::fromStdString(response->result.error_message));
        return;
    }
    // Process the response
    QString message = QString::asprintf("Spawned as %s", response->entity_name.c_str());
    QMessageBox::information(this, "Success", message);


}

void MyWidget::GetSpawnables() {
    // Create a client for the GetSpawnables service
    auto client = node_->create_client<simulation_interfaces::srv::GetSpawnables>("/get_spawnables");
    if (!client->wait_for_service(std::chrono::seconds(10))) {
        RCLCPP_ERROR(node_->get_logger(), "Service not available after waiting");
        return;
    }
    auto request = std::make_shared<simulation_interfaces::srv::GetSpawnables::Request>();

    // Call the service
    auto future = client->async_send_request(request);
    if (rclcpp::spin_until_future_complete(node_, future) !=
        rclcpp::FutureReturnCode::SUCCESS) {
        RCLCPP_ERROR(node_->get_logger(), "Failed to call service");
        return;
    }
    auto response = future.get();
    if (response->result.result != simulation_interfaces::msg::Result::RESULT_OK) {
        RCLCPP_ERROR(node_->get_logger(), "Service call failed: %s", response->result.error_message.c_str());
        return;
    }
    // Process the response
    ui_->ComboSpawables->clear();
    for (const auto &spawnable: response->spawnables) {
        ui_->ComboSpawables->addItem(QString::fromStdString(spawnable.uri));
    }
}





